# 3 有关虚函数的注意事项
## 3.1 构造函数

&emsp;&emsp;**构造函数不能是虚函数**

$$
创建派生类对象：派生类的构造函数 \rightarrow 基类构造函数
$$

构造函数遵从函数调用机制，而不是继承机制，派生类不能继承基类的构造函数。

## 3.2 析构函数
&emsp;&emsp;**如果用作基类，析构函数应该是虚函数**

**静态联编**：先调用基类的构造函数，释放基类组件指向的内存，留下新的类成员指向的内存。
**动态联编**：先调用派生类析构函数，释放派生类组件指向的内存，**再调用基类析构函数**，释放基类组件指向的内存。

## 3.3 友元
&emsp;&emsp;**友元不能是虚函数**：因为友元不是类成员，而只有成员才能是虚函数。可以通过让友元函数使用虚成员函数来解决设计的问题。
## 3.4 没有重新定义
&emsp;&emsp;如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本。
## 3.5 重新定义将隐藏方法
&emsp;&emsp;重新定义将隐藏基类版本，而不是生成函数的两个重载版本
经验规则：
+ 如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。这种特性叫返回类型协变。
+ 如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。

# 5. 访问控制： `protected`
&emsp;&emsp;**派生类成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员**

对于外部世界来说，保护成员和私有成员相同；对于派生类来说，保护成员的行为与共有成员相同

# 7. 继承和动态内存分配
## 7.1 派生类不使用动态内存分配
## 7.2 派生类使用动态内存分配

&emsp;&emsp;**当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数、赋值运算符都必须使用相应的基类方法来处理基类元素**

1. 析构函数：自动完成
2. 构造函数：在初始化成员列表中调用基类的复制构造函数来完成，否则将自动调用基类的默认构造函数；
3. 赋值运算符：作用域解析运算符显式地调用基类的赋值运算符

# 8. 类设计回顾
## 8.1 编译器生成的成员函数
### 8.1.1 默认构造函数
1. 编译器将定义默认构造函数，如果不显式定义
2. 派生类构造函数成员初始化
&emsp;&emsp;如果派生类构造函数的成员初始化列表中没有显式调用基类构造函数，则编译器将使用基类的默认构造函数来构造派生类对象的基类部分。
### 8.1.2 复制构造函数
1. 同类初始化：将新对象初始化为一个同类对象
2. 值传递：按值将对象传递给函数
3. 值返回：按值返回对象
4. 临时对象：编译器生成临时对象

### 8.1.3 赋值运算符
1. 场景：同类对象间的赋值

2. 赋值 VS 初始化
    + 创建新的对象：初始化
    + 修改已有对象的值：赋值

3. 成员赋值(默认)
    + 成员为类对象：使用相应类的赋值运算符
    + 显式定义复制构造函数，也需要显式定义赋值运算符

4. 转换函数

5. 移动构造函数

6. 移动赋值运算符

## 8.2 其他类方法
### 8.2.1 构造函数
&emsp;&emsp;**构造函数不能被继承的原因**：构造函数创建对象，其他类方法只能被已有的对象调用。

&emsp;&emsp;**继承——派生类对象可以使用基类的方法，然而，在构造函数执行前，对象不存在。**
### 8.2.2 析构函数
&emsp;&emsp;一定要定义显式析构函数来释放类构造函数使用 `new` 分配的所有内存，并完成类对象所需的任何特殊的清理工作。

&emsp;&emsp;对于基类，即使它不需要析构函数，也应当提供一个虚析构函数。

### 8.2.3 转换
&emsp;&emsp;使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换。
&emsp;&emsp;将可转换的类型传递给以类为参数的函数时，将调用转换构造函数。
&emsp;&emsp;**在一个带参数的构造函数原型中使用 `explicit` 将禁止进行隐式转换，但仍允许显式转换。**

```C++
class Star {
    //...
    public:
        explicit Star(const char *);
    //...
};
//...
Star north;
north = "polaris";          // 隐式转换，不允许
north = Star("polaris");    // 显式转换，允许
```
将类对象转换为其他类型，应定义转换函数。转换函数可以是没有参数的类成员函数，也可以是返回类型被声明为目标类型的类成员函数

```C++
Star::Star double() {...}               // 将 Star 类型转化为 double 类型
Star::Star const char * () {...}        // 转换为 const char 类型
```

### 8.2.4 值传递 VS 引用传递
&emsp;&emsp;**按引用传递效率高**：编写使用对象作为参数的函数时，应按引用而不是按值来传递对象

按值传递对象：
1. 调用复制构造函数，生成临时拷贝
2. 调用析构函数，回收对象的内存资源

&emsp;&emsp;如果函数不修改对象，应将参数声明为 const 引用。

按引用传递对象的原因之二：在继承使用虚函数时，被定义为接受基类引用参数的函数，可以接受派生类。

### 8.2.5 返回对象和返回引用
1. 返回引用的效率更高

返回对象的过程：
+ 调用复制构造函数生成副本
+ 调用析构函数删除副本

2. 不能返回函数内部创建的临时对象的引用

3. 返回输入的引用

### 8.2.6 使用 const
1. const 在前，修饰函数的返回对象：返回对象为 const
2. const 在中，修饰函数的输入参数：不允许修改输入参数
3. const 在后，修饰函数的调用者：不修改调用对象

## 8.3 公有继承的考虑因素
### 8.3.1 `is-a` 关系
&emsp;&emsp;**公有派生**：派生类是一个基类，拥有基类的所有属性

无需进行显式类型转换，基类指针可以指向派生类对象

### 8.3.2 什么不能被继承
1. **构造函数不能被继承**
    + 创建派生类对象时，必须**调用**派生类的构造函数。
    + 派生类构造函数通常使用成员初始化列表来调用基类构造函数，以创建派生对象的基类部分。
    + 如果派生类构造函数没有使用成员初始化列表语法显式调用基类构造函数，将使用基类的默认构造函数

2. **析构函数不能继承**
    + 释放对象时，首先调用派生类的析构函数，再调用基类的析构函数
    + 如果基类没有默认的析构函数，编译器将为派生类生成默认析构函数
    + 通常，基类的析构函数应该设置为虚的

3. **赋值运算符不能被继承**
    + 派生类继承的方法的特征标与基类完全相同，但赋值运算符的特征标随类而异

### 8.3.3 赋值运算符
&emsp;&emsp;如果编译器发现程序将一个对象赋给同一个类的另一个对象，它将自动为这个类提供一个赋值运算符。这个运算符的默认或隐式版本将采用成员赋值，即将原对象的相应成员赋给目标对象的每个成员。

### 8.2.4 私有成员 VS 保护成员
+ 对派生类而言，保护成员类似于公有成员
+ 对于外部而言，保护成员与私有成员类似

派生类可以直接访问基类的保护成员，但只能通过基类的成员函数访问私有成员。

将基类成员设置为私有可以提高安全性
### 8.2.5 虚方法
&emsp;&emsp;设计基类时，必须确定是否将类方法声明为虚的。如果希望派生类能够重新定义方法，则应在基类中将方法定义为虚的，这样可以启用晚期联编译

### 8.2.6 析构函数
基类的析构函数应当是虚的
