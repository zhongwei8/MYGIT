# 1. 面向对象
## 1.1 静态成员变量
## 1.2 静态成员函数
&emsp;&emsp;静态成员函数属于类本身，而不作用于对象，因此它不具有 this 指针。由于静态成员函数没有指向任何一个对象，所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量。
静态成员函数的特点：
1. 出现在类体外的函数定义不能指定关键字 static。
2. 静态成员之间可以相互访问，即静态成员函数(仅)可以访问静态成员变量、静态成员函数。
3. 静态成员函数不能访问非静态成员函数和非京台成员变量；
4. 非静态成员函数可以任意地访问静态成员函数和静态成员变量
5. 由于没有 this 指针的额外开销，静态成员函数与类的全局函数相比速度会稍快；
6. 调用静态成员函数，两种方式：
    + 通过对象访问：成员访问操作符号 "." 和 "->"，也即通过类对象或指向类对象的指针调用静态成员函数；
    + 通过类访问：直接通过类来调用静态成员函数。<类名>::<静态成员函数名>(<参数表>)
# 2. 面向过程
## 2.1 静态全局变量
&emsp;&emsp;在全局变量前，加关键字 `static`，该变量就变成一个静态全局变量。

静态全局变量的特点：
+ 在全局内存区分配
+ 默认初始化为零
+ 整个文件可见
+ 静态变量都在全局数据区分配内存。

全局变量 VS 静态全局变量：
+ 影藏：静态全局变量不能被其他文件所用

&emsp;&emsp;一个完整的程序，内存分布如下
+ 代码区
+ 全局数据区：静态数据
+ 堆区：由 new 产生的动态数据
+ 栈区：函数内部的自动变量
## 2.2 静态局部变量
&emsp;&emsp;在局部变量前，加上关键字 static，该变量就被定义为一个静态局部变量。
&emsp;&emsp;**即生即灭**：在函数体内定义一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存，随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。
&emsp;&emsp;**生而不灭**：静态局部变量保存在全局数据区，而不是保存在栈中，每一次的值保持到下一次调用，直到下次重赋新值。
&emsp;&emsp;静态局部变量有一下特点：
1. 在全局数据区分配内存；
2. 在程序首次执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
3. 静态局部变量一般再声明处初始化，如果没有显示初始化，会被程序自动初始化为零；
4. 静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句结束后，其作用域随之结束。
## 2.3 静态函数
&emsp;&emsp;在函数的返回类型前加上 static 关键字，函数即被定义为静态函数。

**隐藏**：静态函数只能在声明它的文件当中可见，不能被其他文件使用，实现了不同文件间函数的隔离。
